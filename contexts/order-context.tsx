"use client"

import type React from "react"
import { createContext, useContext, useState, useEffect } from "react"

interface OrderItem {
  id: string
  name: string
  category: string
  volume: string
  bottlesPerCase: number
  requestedQuantity: number
  unit: string
  description?: string
  salesmanPrice?: number
  adminPrice?: number
  finalPrice?: number
  gstBill?: "yes" | "no"
  gstNumber?: string
  unitPrice?: number
  lineTotal?: number
}

interface Client {
  id: string
  partyName: string // Main field from 'Party Name' column
  clientName: string // Extracted clean name for display
  address: string // Extracted or direct address
  city: string // From 'City' column
  area: string // From 'Area' column (Area/Locality)
  contactPerson: string // From 'Contact Person' column
  contactNumber: string // From 'Contact Number' column
  gstNumber: string // From 'GST Number' column
  email?: string // Optional email
  serialNumber?: string // Internal S.No. tracking
  createdAt: string
  createdBy: string
  lastUsed?: string
  orderCount?: number
  // Legacy fields for backward compatibility
  name?: string
  phone?: string
}

interface Bill {
  id: string
  orderId: string
  orderNumber: string
  salesmanId: string
  salesmanName: string
  clientId: string
  clientName: string
  items: OrderItem[]
  subtotal: number
  tax: number
  total: number
  billType: "regular" | "gst"
  gstNumber?: string
  status: "generated" | "verified" | "processed" | "rejected"
  generatedAt: string
  verifiedAt?: string
  processedAt?: string
  adminNotes?: string
  createdBy: "salesman" | "admin"
}

interface Order {
  id: string
  orderNumber?: string
  salesmanId: string
  salesmanName: string
  clientId: string
  clientName: string
  items: OrderItem[]
  status: "pending" | "admin_priced" | "salesman_adjusted" | "approved" | "rejected" | "completed"
  totalItems: number
  notes: string
  createdAt: string
  createdBy?: string // Additional field for tracking who created the order
  adminPricedAt?: string
  salesmanAdjustedAt?: string
  approvedAt?: string
  adminNotes?: string
  salesmanAdjustmentNotes?: string
  allowPriceAdjustment?: boolean
  priceAdjustmentRange?: { min: number; max: number }
  salesmanPricing?: {
    subtotal: number
    tax: number
    total: number
    itemPrices: Record<string, number>
    withGst: boolean
    priceAdjustments?: Record<string, number>
  }
  adminPricing?: {
    subtotal: number
    tax: number
    total: number
    itemPrices: Record<string, number>
  }
  finalPricing?: {
    subtotal: number
    tax: number
    total: number
    itemPrices: Record<string, number>
    adjustments: Record<string, number>
  }
  billGenerated?: boolean
  billId?: string
  withGst?: boolean
  gstNumber?: string
  isEditable?: boolean
  autoGeneratedBill?: boolean
  // Add data integrity fields
  dataVersion?: string
  lastModified?: string
  backupTimestamp?: string
  retentionProtected?: boolean
  retentionExpiresAt?: string
  daysRemaining?: number
  archivedAt?: string
  retentionExpired?: boolean
}

// 30-Day Permanent Retention Policy
const RETENTION_POLICY = {
  RETENTION_DAYS: 30,
  ARCHIVE_AFTER_DAYS: 30,
  CLEANUP_CHECK_INTERVAL: 24 * 60 * 60 * 1000, // 24 hours
  PERMANENT_PROTECTION_PERIOD: 30 * 24 * 60 * 60 * 1000, // 30 days in milliseconds
} as const

interface RetentionStatus {
  orderId: string
  createdAt: string
  retentionExpiresAt: string
  daysRemaining: number
  isProtected: boolean
  canBeArchived: boolean
  archiveDate?: string
}

interface DataRetentionInfo {
  totalProtectedOrders: number
  ordersNearExpiry: number
  archivedOrdersCount: number
  retentionPolicyActive: boolean
  lastRetentionCheck: string
  nextCleanupDate: string
}

interface DataIntegrity {
  totalOrders: number
  lastBackup: string
  dataVersion: string
  backupCount: number
  retentionInfo: DataRetentionInfo
  permanentProtectionActive: boolean
}

interface OrderContextType {
  orders: Order[]
  clients: Client[]
  bills: Bill[]
  availableItems: OrderItem[]
  isDataLoaded: boolean
  orderCounter: number
  dataIntegrity: DataIntegrity
  retentionInfo: DataRetentionInfo
  addOrder: (order: Omit<Order, "id" | "createdAt" | "orderNumber">) => void
  updateOrder: (orderId: string, updates: Partial<Order>) => void
  adjustOrderPricing: (orderId: string, priceAdjustments: Record<string, number>) => void
  addClient: (client: Omit<Client, "id" | "createdAt">) => void
  updateClient: (clientId: string, updates: Partial<Client>) => void
  deleteClient: (clientId: string) => void
  checkClientExists: (name: string, email?: string) => Client | null
  getClientById: (clientId: string) => Client | null
  getClientOrderHistory: (clientId: string) => Order[]
  generateBill: (orderId: string, billType: "regular" | "gst", gstNumber?: string) => Bill | null
  updateBillStatus: (billId: string, status: Bill["status"], adminNotes?: string) => void
  setAdminPricing: (
    orderId: string,
    pricing: Order["adminPricing"],
    adminNotes?: string,
    allowAdjustment?: boolean,
  ) => void
  setSalesmanAdjustment: (orderId: string, adjustments: Record<string, number>, notes?: string) => void
  updateOrderStatus: (orderId: string, status: Order["status"]) => void
  approveOrder: (orderId: string) => void
  rejectOrder: (orderId: string, reason: string) => void
  getOrderPricingSummary: () => {
    totalOrders: number
    totalValue: number
    pendingValue: number
    approvedValue: number
    averageOrderValue: number
  }
  refreshData: () => void
  clearAllData: () => void
  exportBackup: () => void
  createManualBackup: () => void
  verifyDataIntegrity: () => {
    saveCounter: number
    orderCount: number
    clientCount: number
    billCount: number
    isHealthy: boolean
  }
  getOrderRetentionStatus: (orderId: string) => RetentionStatus | null
  getOrdersNearExpiry: () => Order[]
  getArchivedOrders: () => Order[]
  enforceRetentionPolicy: () => void
  getRetentionSummary: () => {
    totalOrders: number
    protectedOrders: number
    nearExpiryOrders: number
    archivedOrders: number
    retentionCompliance: boolean
  }
}

const OrderContext = createContext<OrderContextType | undefined>(undefined)

// Add enhanced data persistence with immediate saves and multiple recovery layers

// Enhanced storage keys with multiple backup levels
const STORAGE_KEYS = {
  // Primary storage
  ORDERS: "wims-orders-v8-primary",
  CLIENTS: "wims-clients-v8-primary",
  BILLS: "wims-bills-v8-primary",
  ORDER_COUNTER: "wims-order-counter-v8",

  // Backup storage (redundant copies)
  ORDERS_BACKUP: "wims-orders-v8-backup",
  CLIENTS_BACKUP: "wims-clients-v8-backup",
  BILLS_BACKUP: "wims-bills-v8-backup",

  // Emergency backup (additional redundancy)
  ORDERS_EMERGENCY: "wims-orders-v8-emergency",
  CLIENTS_EMERGENCY: "wims-clients-v8-emergency",
  BILLS_EMERGENCY: "wims-bills-v8-emergency",

  // Archive storage (long-term backup)
  ORDERS_ARCHIVE: "wims-orders-v8-archive",
  CLIENTS_ARCHIVE: "wims-clients-v8-archive",
  BILLS_ARCHIVE: "wims-bills-v8-archive",

  // Metadata and integrity
  LAST_SYNC: "wims-last-sync-v8",
  DATA_INTEGRITY: "wims-data-integrity-v8",
  BACKUP_HISTORY: "wims-backup-history-v8",
  SAVE_COUNTER: "wims-save-counter-v8",

  // 30-Day Retention Management
  RETENTION_STATUS: "wims-retention-status-v8",
  ARCHIVED_ORDERS: "wims-archived-orders-v8",
  RETENTION_LOG: "wims-retention-log-v8",
  LAST_RETENTION_CHECK: "wims-last-retention-check-v8",
} as const

// Enhanced utility functions for ultra-safe localStorage operations
const safeLocalStorageGet = (key: string, defaultValue: any = null) => {
  try {
    if (typeof window === "undefined") return defaultValue

    const item = localStorage.getItem(key)
    if (!item || item === "undefined" || item === "null") {
      return defaultValue
    }

    if (item.trim().length === 0) {
      return defaultValue
    }

    const parsed = JSON.parse(item)
    return parsed
  } catch (error) {
    console.warn(`Error reading from localStorage key "${key}":`, error)
    return defaultValue
  }
}

const safeLocalStorageSet = (key: string, value: any) => {
  try {
    if (typeof window === "undefined") return false

    if (value === undefined) {
      return false // Never remove data, just skip undefined values
    }

    const serialized = JSON.stringify(value)
    localStorage.setItem(key, serialized)

    // Update last sync timestamp
    const timestamp = new Date().toISOString()
    localStorage.setItem(STORAGE_KEYS.LAST_SYNC, JSON.stringify(timestamp))

    return true
  } catch (error) {
    console.error(`Error writing to localStorage key "${key}":`, error)
    return false
  }
}

// Enhanced immediate save with quadruple redundancy
const immediateQuadrupleSave = (
  key: string,
  backupKey: string,
  emergencyKey: string,
  archiveKey: string,
  data: any,
) => {
  try {
    // Save to all 4 locations immediately
    const success1 = safeLocalStorageSet(key, data)
    const success2 = safeLocalStorageSet(backupKey, data)
    const success3 = safeLocalStorageSet(emergencyKey, data)
    const success4 = safeLocalStorageSet(archiveKey, data)

    // Update save counter
    const saveCounter = safeLocalStorageGet(STORAGE_KEYS.SAVE_COUNTER, 0) + 1
    safeLocalStorageSet(STORAGE_KEYS.SAVE_COUNTER, saveCounter)

    // Log successful saves
    console.log(`âœ… PERMANENT SAVE #${saveCounter}: ${key} saved to 4 locations`, {
      primary: success1,
      backup: success2,
      emergency: success3,
      archive: success4,
    })

    return success1 && success2 && success3 && success4
  } catch (error) {
    console.error("âŒ CRITICAL: Failed to save data permanently:", error)
    return false
  }
}

// Multi-level backup system
const createMultiLevelBackup = (key: string, backupKey: string, emergencyKey: string, data: any) => {
  try {
    // Primary storage
    safeLocalStorageSet(key, data)

    // Backup storage
    safeLocalStorageSet(backupKey, data)

    // Emergency backup
    safeLocalStorageSet(emergencyKey, data)

    // Update backup history
    const backupHistory = safeLocalStorageGet(STORAGE_KEYS.BACKUP_HISTORY, [])
    backupHistory.push({
      timestamp: new Date().toISOString(),
      key: key,
      dataSize: JSON.stringify(data).length,
      recordCount: Array.isArray(data) ? data.length : 1,
    })

    // Keep only last 50 backup entries
    if (backupHistory.length > 50) {
      backupHistory.splice(0, backupHistory.length - 50)
    }

    safeLocalStorageSet(STORAGE_KEYS.BACKUP_HISTORY, backupHistory)

    return true
  } catch (error) {
    console.error("Error creating multi-level backup:", error)
    return false
  }
}

// Quadruple-level data recovery with archive fallback
const recoverDataFromAllBackups = (
  key: string,
  backupKey: string,
  emergencyKey: string,
  archiveKey: string,
  defaultValue: any = [],
) => {
  // Try primary storage first
  let data = safeLocalStorageGet(key, null)
  if (data && Array.isArray(data) && data.length > 0) {
    console.log(`âœ… Data recovered from primary storage: ${key} (${data.length} records)`)
    return data
  }

  // Try backup storage
  data = safeLocalStorageGet(backupKey, null)
  if (data && Array.isArray(data) && data.length > 0) {
    console.log(`ðŸ”„ Data recovered from backup storage: ${backupKey} (${data.length} records)`)
    // Restore to primary
    safeLocalStorageSet(key, data)
    return data
  }

  // Try emergency backup
  data = safeLocalStorageGet(emergencyKey, null)
  if (data && Array.isArray(data) && data.length > 0) {
    console.log(`ðŸš¨ Data recovered from emergency backup: ${emergencyKey} (${data.length} records)`)
    // Restore to primary and backup
    safeLocalStorageSet(key, data)
    safeLocalStorageSet(backupKey, data)
    return data
  }

  // Try archive backup (final fallback)
  data = safeLocalStorageGet(archiveKey, null)
  if (data && Array.isArray(data) && data.length > 0) {
    console.log(`ðŸ“¦ Data recovered from archive backup: ${archiveKey} (${data.length} records)`)
    // Restore to all locations
    safeLocalStorageSet(key, data)
    safeLocalStorageSet(backupKey, data)
    safeLocalStorageSet(emergencyKey, data)
    return data
  }

  console.warn(`âš ï¸ No data found in any backup for: ${key}`)
  return defaultValue
}

// Multi-level data recovery
const recoverDataFromBackups = (key: string, backupKey: string, emergencyKey: string, defaultValue: any = []) => {
  // Try primary storage first
  let data = safeLocalStorageGet(key, null)
  if (data && Array.isArray(data) && data.length > 0) {
    console.log(`âœ… Data recovered from primary storage: ${key}`)
    return data
  }

  // Try backup storage
  data = safeLocalStorageGet(backupKey, null)
  if (data && Array.isArray(data) && data.length > 0) {
    console.log(`ðŸ”„ Data recovered from backup storage: ${backupKey}`)
    // Restore to primary
    safeLocalStorageSet(key, data)
    return data
  }

  // Try emergency backup
  data = safeLocalStorageGet(emergencyKey, null)
  if (data && Array.isArray(data) && data.length > 0) {
    console.log(`ðŸš¨ Data recovered from emergency backup: ${emergencyKey}`)
    // Restore to primary and backup
    safeLocalStorageSet(key, data)
    safeLocalStorageSet(backupKey, data)
    return data
  }

  console.warn(`âš ï¸ No data found in any backup for: ${key}`)
  return defaultValue
}

// 30-Day Permanent Retention Management
const calculateRetentionStatus = (order: Order): RetentionStatus => {
  const createdDate = new Date(order.createdAt)
  const retentionExpiresAt = new Date(createdDate.getTime() + RETENTION_POLICY.PERMANENT_PROTECTION_PERIOD)
  const now = new Date()
  const daysRemaining = Math.ceil((retentionExpiresAt.getTime() - now.getTime()) / (24 * 60 * 60 * 1000))

  return {
    orderId: order.id,
    createdAt: order.createdAt,
    retentionExpiresAt: retentionExpiresAt.toISOString(),
    daysRemaining: Math.max(0, daysRemaining),
    isProtected: daysRemaining > 0,
    canBeArchived: daysRemaining <= 0,
    archiveDate: daysRemaining <= 0 ? new Date().toISOString() : undefined,
  }
}

const enforceRetentionPolicy = (orders: Order[]) => {
  const now = new Date()
  const protectedOrders: Order[] = []
  const ordersToArchive: Order[] = []

  orders.forEach((order) => {
    const retentionStatus = calculateRetentionStatus(order)

    if (retentionStatus.isProtected) {
      // Order is within 30-day protection period
      protectedOrders.push({
        ...order,
        retentionProtected: true,
        retentionExpiresAt: retentionStatus.retentionExpiresAt,
        daysRemaining: retentionStatus.daysRemaining,
      })
    } else {
      // Order can be archived (but not deleted)
      ordersToArchive.push({
        ...order,
        retentionProtected: false,
        archivedAt: now.toISOString(),
        retentionExpired: true,
      })
    }
  })

  // Archive expired orders (move to archive storage, don't delete)
  if (ordersToArchive.length > 0) {
    const existingArchived = safeLocalStorageGet(STORAGE_KEYS.ARCHIVED_ORDERS, [])
    const updatedArchived = [...existingArchived, ...ordersToArchive]
    safeLocalStorageSet(STORAGE_KEYS.ARCHIVED_ORDERS, updatedArchived)

    // Log retention actions
    const retentionLog = safeLocalStorageGet(STORAGE_KEYS.RETENTION_LOG, [])
    retentionLog.push({
      timestamp: now.toISOString(),
      action: "ARCHIVE_EXPIRED_ORDERS",
      orderCount: ordersToArchive.length,
      orderIds: ordersToArchive.map((o) => o.id),
    })
    safeLocalStorageSet(STORAGE_KEYS.RETENTION_LOG, retentionLog.slice(-100)) // Keep last 100 logs
  }

  return protectedOrders
}

const getRetentionInfo = (orders: Order[]): DataRetentionInfo => {
  const retentionStatuses = orders.map(calculateRetentionStatus)
  const protectedOrders = retentionStatuses.filter((status) => status.isProtected)
  const ordersNearExpiry = retentionStatuses.filter((status) => status.daysRemaining <= 3 && status.daysRemaining > 0)
  const archivedOrders = safeLocalStorageGet(STORAGE_KEYS.ARCHIVED_ORDERS, [])
  const lastCheck = safeLocalStorageGet(STORAGE_KEYS.LAST_RETENTION_CHECK, new Date().toISOString())

  return {
    totalProtectedOrders: protectedOrders.length,
    ordersNearExpiry: ordersNearExpiry.length,
    archivedOrdersCount: archivedOrders.length,
    retentionPolicyActive: true,
    lastRetentionCheck: lastCheck,
    nextCleanupDate: new Date(Date.now() + RETENTION_POLICY.CLEANUP_CHECK_INTERVAL).toISOString(),
  }
}

export function OrderProvider({ children }: { children: React.ReactNode }) {
  const [orders, setOrders] = useState<Order[]>([])
  const [clients, setClients] = useState<Client[]>([])
  const [bills, setBills] = useState<Bill[]>([])
  const [isDataLoaded, setIsDataLoaded] = useState(false)
  const [orderCounter, setOrderCounter] = useState(1)
  const [dataIntegrity, setDataIntegrity] = useState<DataIntegrity>({
    totalOrders: 0,
    lastBackup: "Never",
    dataVersion: "v8",
    backupCount: 4, // Updated to reflect quadruple redundancy
    retentionInfo: {
      totalProtectedOrders: 0,
      ordersNearExpiry: 0,
      archivedOrdersCount: 0,
      retentionPolicyActive: true,
      lastRetentionCheck: new Date().toISOString(),
      nextCleanupDate: new Date(Date.now() + RETENTION_POLICY.CLEANUP_CHECK_INTERVAL).toISOString(),
    },
    permanentProtectionActive: true,
  })

  const [retentionInfo, setRetentionInfo] = useState<DataRetentionInfo>({
    totalProtectedOrders: 0,
    ordersNearExpiry: 0,
    archivedOrdersCount: 0,
    retentionPolicyActive: true,
    lastRetentionCheck: new Date().toISOString(),
    nextCleanupDate: new Date(Date.now() + RETENTION_POLICY.CLEANUP_CHECK_INTERVAL).toISOString(),
  })

  const [availableItems] = useState<OrderItem[]>([
    {
      id: "1",
      name: "Litchi",
      category: "Fruit Juice",
      volume: "160 ml",
      bottlesPerCase: 40,
      requestedQuantity: 0,
      unit: "cases",
      description: "Litchi flavored juice - 160ml bottles, 40 bottles per case",
      unitPrice: 320,
    },
    {
      id: "2",
      name: "Mango",
      category: "Fruit Juice",
      volume: "160 ml",
      bottlesPerCase: 40,
      requestedQuantity: 0,
      unit: "cases",
      description: "Mango flavored juice - 160ml bottles, 40 bottles per case",
      unitPrice: 340,
    },
    {
      id: "3",
      name: "Guava",
      category: "Fruit Juice",
      volume: "160 ml",
      bottlesPerCase: 40,
      requestedQuantity: 0,
      unit: "cases",
      description: "Guava flavored juice - 160ml bottles, 40 bottles per case",
      unitPrice: 330,
    },
    {
      id: "4",
      name: "Mix Fruit",
      category: "Fruit Juice",
      volume: "160 ml",
      bottlesPerCase: 40,
      requestedQuantity: 0,
      unit: "cases",
      description: "Mixed fruit flavored juice - 160ml bottles, 40 bottles per case",
      unitPrice: 350,
    },
    {
      id: "5",
      name: "Orange",
      category: "Fruit Juice",
      volume: "160 ml",
      bottlesPerCase: 40,
      requestedQuantity: 0,
      unit: "cases",
      description: "Orange flavored juice - 160ml bottles, 40 bottles per case",
      unitPrice: 335,
    },
  ])

  // Initialize data with enhanced recovery mechanisms
  useEffect(() => {
    const initializeData = () => {
      try {
        console.log("ðŸ”„ Initializing WIMS data with enhanced recovery...")

        // Load data with multi-level backup recovery
        const savedOrders = recoverDataFromAllBackups(
          STORAGE_KEYS.ORDERS,
          STORAGE_KEYS.ORDERS_BACKUP,
          STORAGE_KEYS.ORDERS_EMERGENCY,
          STORAGE_KEYS.ORDERS_ARCHIVE,
          [],
        )

        const savedClients = recoverDataFromAllBackups(
          STORAGE_KEYS.CLIENTS,
          STORAGE_KEYS.CLIENTS_BACKUP,
          STORAGE_KEYS.CLIENTS_EMERGENCY,
          STORAGE_KEYS.CLIENTS_ARCHIVE,
          [],
        )

        const savedBills = recoverDataFromAllBackups(
          STORAGE_KEYS.BILLS,
          STORAGE_KEYS.BILLS_BACKUP,
          STORAGE_KEYS.BILLS_EMERGENCY,
          STORAGE_KEYS.BILLS_ARCHIVE,
          [],
        )

        const savedOrderCounter = safeLocalStorageGet(STORAGE_KEYS.ORDER_COUNTER, 1)

        // Enhanced validation - be more permissive to avoid data loss
        const validOrders = Array.isArray(savedOrders)
          ? savedOrders.filter((order) => {
              // Minimal validation to prevent data loss
              return order && typeof order === "object" && order.id && (order.salesmanName || order.salesmanId)
            })
          : []

        // Ensure orders have all required fields with defaults
        const ordersWithDefaults = validOrders.map((order: Order, index: number) => ({
          ...order,
          orderNumber: order.orderNumber || `OID${String(index + 1).padStart(3, "0")}`,
          status: order.status || "pending",
          items: Array.isArray(order.items) ? order.items : [],
          notes: order.notes || "",
          totalItems: order.totalItems || (Array.isArray(order.items) ? order.items.length : 0),
          createdAt: order.createdAt || new Date().toISOString(),
          isEditable: order.isEditable !== false,
          // Handle legacy vendor -> client migration
          clientId: order.clientId || (order as any).vendorId || `CLI-${Date.now()}`,
          clientName: order.clientName || (order as any).vendorName || "Unknown Client",
          // Add data integrity fields
          dataVersion: "v7",
          lastModified: new Date().toISOString(),
          backupTimestamp: new Date().toISOString(),
        }))

        // Enhanced client validation
        const validClients = Array.isArray(savedClients)
          ? savedClients
              .filter((client) => client && typeof client === "object" && client.id)
              .map((client) => ({
                ...client,
                partyName: client.partyName || client.name || "Unknown Party",
                clientName: client.clientName || client.name || "Unknown Client",
                address: client.address || "",
                city: client.city || "",
                area: client.area || "",
                contactPerson: client.contactPerson || "",
                contactNumber: client.contactNumber || client.phone || "",
                gstNumber: client.gstNumber || "",
                email: client.email || "",
                orderCount: client.orderCount || 0,
                lastUsed: client.lastUsed || client.createdAt || new Date().toISOString(),
                createdBy: client.createdBy || "system",
              }))
          : []

        // Enhanced bill validation
        const validBills = Array.isArray(savedBills)
          ? savedBills.filter((bill) => bill && typeof bill === "object" && bill.id && bill.orderId)
          : []

        // Update client order counts
        const clientOrderCounts = ordersWithDefaults.reduce(
          (acc, order) => {
            if (order.clientId) {
              acc[order.clientId] = (acc[order.clientId] || 0) + 1
            }
            return acc
          },
          {} as Record<string, number>,
        )

        const clientsWithCounts = validClients.map((client) => ({
          ...client,
          orderCount: clientOrderCounts[client.id] || 0,
        }))

        // Set state with validated data
        setOrders(ordersWithDefaults)
        setClients(clientsWithCounts)
        setBills(validBills)
        setOrderCounter(Math.max(savedOrderCounter, ordersWithDefaults.length + 1))

        // Update data integrity info
        setDataIntegrity({
          totalOrders: ordersWithDefaults.length,
          lastBackup: new Date().toLocaleString(),
          dataVersion: "v7",
          backupCount: 3,
          retentionInfo: {
            totalProtectedOrders: 0,
            ordersNearExpiry: 0,
            archivedOrdersCount: 0,
            retentionPolicyActive: true,
            lastRetentionCheck: new Date().toISOString(),
            nextCleanupDate: new Date(Date.now() + RETENTION_POLICY.CLEANUP_CHECK_INTERVAL).toISOString(),
          },
          permanentProtectionActive: true,
        })

        setRetentionInfo(getRetentionInfo(ordersWithDefaults))

        console.log(
          `âœ… Successfully loaded ${ordersWithDefaults.length} orders, ${clientsWithCounts.length} clients, and ${validBills.length} bills`,
        )

        // Create immediate backup after successful load
        setTimeout(() => {
          createMultiLevelBackup(
            STORAGE_KEYS.ORDERS,
            STORAGE_KEYS.ORDERS_BACKUP,
            STORAGE_KEYS.ORDERS_EMERGENCY,
            ordersWithDefaults,
          )
          createMultiLevelBackup(
            STORAGE_KEYS.CLIENTS,
            STORAGE_KEYS.CLIENTS_BACKUP,
            STORAGE_KEYS.CLIENTS_EMERGENCY,
            clientsWithCounts,
          )
          createMultiLevelBackup(
            STORAGE_KEYS.BILLS,
            STORAGE_KEYS.BILLS_BACKUP,
            STORAGE_KEYS.BILLS_EMERGENCY,
            validBills,
          )
        }, 1000)

        setIsDataLoaded(true)
      } catch (error) {
        console.error("âŒ Error initializing data:", error)
        // Even on error, mark as loaded to prevent infinite loading
        setIsDataLoaded(true)
      }
    }

    const timer = setTimeout(initializeData, 100)
    return () => clearTimeout(timer)
  }, [])

  // Enhanced auto-save with multi-level backup
  useEffect(() => {
    if (isDataLoaded && orders.length >= 0) {
      immediateQuadrupleSave(
        STORAGE_KEYS.ORDERS,
        STORAGE_KEYS.ORDERS_BACKUP,
        STORAGE_KEYS.ORDERS_EMERGENCY,
        STORAGE_KEYS.ORDERS_ARCHIVE,
        orders,
      )

      setDataIntegrity((prev) => ({
        ...prev,
        totalOrders: orders.length,
        lastBackup: new Date().toLocaleString(),
      }))
    }
  }, [orders, isDataLoaded])

  useEffect(() => {
    if (isDataLoaded && clients.length >= 0) {
      immediateQuadrupleSave(
        STORAGE_KEYS.CLIENTS,
        STORAGE_KEYS.CLIENTS_BACKUP,
        STORAGE_KEYS.CLIENTS_EMERGENCY,
        STORAGE_KEYS.CLIENTS_ARCHIVE,
        clients,
      )
    }
  }, [clients, isDataLoaded])

  useEffect(() => {
    if (isDataLoaded && bills.length >= 0) {
      immediateQuadrupleSave(
        STORAGE_KEYS.BILLS,
        STORAGE_KEYS.BILLS_BACKUP,
        STORAGE_KEYS.BILLS_EMERGENCY,
        STORAGE_KEYS.BILLS_ARCHIVE,
        bills,
      )
    }
  }, [bills, isDataLoaded])

  useEffect(() => {
    if (isDataLoaded) {
      safeLocalStorageSet(STORAGE_KEYS.ORDER_COUNTER, orderCounter)
    }
  }, [orderCounter, isDataLoaded])

  // Automatic 30-day retention policy enforcement
  useEffect(() => {
    if (!isDataLoaded) return

    const checkRetentionPolicy = () => {
      const lastCheck = safeLocalStorageGet(STORAGE_KEYS.LAST_RETENTION_CHECK, null)
      const now = new Date()

      // Check if 24 hours have passed since last retention check
      if (!lastCheck || now.getTime() - new Date(lastCheck).getTime() > RETENTION_POLICY.CLEANUP_CHECK_INTERVAL) {
        console.log("ðŸ”’ AUTOMATIC 30-DAY RETENTION CHECK...")

        // Enforce retention policy
        const protectedOrders = enforceRetentionPolicy(orders)

        // Update retention info
        const newRetentionInfo = getRetentionInfo(protectedOrders)
        setRetentionInfo(newRetentionInfo)
        setDataIntegrity((prev) => ({
          ...prev,
          retentionInfo: newRetentionInfo,
          permanentProtectionActive: true,
        }))

        // Update orders if any were archived
        if (protectedOrders.length !== orders.length) {
          setOrders(protectedOrders)
          console.log(`ðŸ“¦ ARCHIVED ${orders.length - protectedOrders.length} orders after 30-day retention period`)
        }

        safeLocalStorageSet(STORAGE_KEYS.LAST_RETENTION_CHECK, now.toISOString())
      }
    }

    // Check retention policy on load
    checkRetentionPolicy()

    // Set up automatic retention policy checks every 24 hours
    const retentionInterval = setInterval(checkRetentionPolicy, RETENTION_POLICY.CLEANUP_CHECK_INTERVAL)

    return () => clearInterval(retentionInterval)
  }, [isDataLoaded, orders])

  // Check if client already exists (prevent duplicates)
  const checkClientExists = (partyName: string, email?: string): Client | null => {
    const trimmedPartyName = partyName.trim().toLowerCase()
    const trimmedEmail = email?.trim().toLowerCase()

    return (
      clients.find((client) => {
        const partyNameMatch =
          client.partyName?.trim().toLowerCase() === trimmedPartyName ||
          client.name?.trim().toLowerCase() === trimmedPartyName // Legacy support
        const clientEmailMatch = trimmedEmail && client.email?.trim().toLowerCase() === trimmedEmail

        return partyNameMatch || clientEmailMatch
      }) || null
    )
  }

  // Get client by ID
  const getClientById = (clientId: string): Client | null => {
    return clients.find((client) => client.id === clientId) || null
  }

  // Get client order history
  const getClientOrderHistory = (clientId: string): Order[] => {
    return orders
      .filter((order) => order.clientId === clientId)
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
  }

  const generateAutomaticBill = (order: Order): Bill | null => {
    const currentPricing = order.salesmanPricing
    if (!currentPricing) {
      console.error("No pricing available for automatic bill generation:", order.id)
      return null
    }

    const billType = order.withGst ? "gst" : "regular"

    const newBill: Bill = {
      id: `BILL-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      orderId: order.id,
      orderNumber: order.orderNumber || "",
      salesmanId: order.salesmanId,
      salesmanName: order.salesmanName,
      clientId: order.clientId,
      clientName: order.clientName,
      items: order.items,
      subtotal: currentPricing.subtotal,
      tax: currentPricing.tax,
      total: currentPricing.total,
      billType,
      gstNumber: order.withGst ? order.gstNumber : undefined,
      status: "generated",
      generatedAt: new Date().toISOString(),
      createdBy: "salesman",
    }

    console.log("ðŸ“„ Auto-generating bill:", newBill.id, "for order:", order.id)
    setBills((prev) => [...prev, newBill])

    return newBill
  }

  const addOrder = (orderData: Omit<Order, "id" | "createdAt" | "orderNumber">) => {
    const orderNumber = `OID${String(orderCounter).padStart(3, "0")}`
    const timestamp = new Date().toISOString()
    const retentionExpiresAt = new Date(Date.now() + RETENTION_POLICY.PERMANENT_PROTECTION_PERIOD).toISOString()

    const newOrder: Order = {
      ...orderData,
      id: `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      orderNumber,
      createdAt: timestamp,
      status: "pending",
      isEditable: true,
      allowPriceAdjustment: true,
      priceAdjustmentRange: { min: 10, max: 15 },
      dataVersion: "v8",
      lastModified: timestamp,
      backupTimestamp: timestamp,
      // Enhanced salesman tracking - multiple ways to identify
      salesmanId: orderData.salesmanId,
      salesmanName: orderData.salesmanName,
      createdBy: orderData.salesmanId, // Additional tracking field
      // 30-day retention fields
      retentionProtected: true,
      retentionExpiresAt,
      daysRemaining: RETENTION_POLICY.RETENTION_DAYS,
    }

    console.log("ðŸ”’ CREATING ORDER WITH ENHANCED SALESMAN TRACKING:", {
      orderId: newOrder.id,
      orderNumber: newOrder.orderNumber,
      salesmanId: newOrder.salesmanId,
      salesmanName: newOrder.salesmanName,
      createdBy: newOrder.createdBy,
      expiresAt: retentionExpiresAt,
    })

    // Update state first
    setOrders((prev) => {
      const updated = [...prev, newOrder]

      // IMMEDIATE PERMANENT SAVE - No delays
      immediateQuadrupleSave(
        STORAGE_KEYS.ORDERS,
        STORAGE_KEYS.ORDERS_BACKUP,
        STORAGE_KEYS.ORDERS_EMERGENCY,
        STORAGE_KEYS.ORDERS_ARCHIVE,
        updated,
      )

      return updated
    })

    setOrderCounter((prev) => prev + 1)

    // Auto-generate bill and save immediately
    const generatedBill = generateAutomaticBill(newOrder)
    if (generatedBill) {
      setOrders((prev) => {
        const updatedWithBill = prev.map((o) =>
          o.id === newOrder.id
            ? {
                ...o,
                billGenerated: true,
                billId: generatedBill.id,
                autoGeneratedBill: true,
                lastModified: new Date().toISOString(),
              }
            : o,
        )

        // Save again with bill info
        immediateQuadrupleSave(
          STORAGE_KEYS.ORDERS,
          STORAGE_KEYS.ORDERS_BACKUP,
          STORAGE_KEYS.ORDERS_EMERGENCY,
          STORAGE_KEYS.ORDERS_ARCHIVE,
          updatedWithBill,
        )

        return updatedWithBill
      })
    }

    // Update client info and save
    setClients((prev) => {
      const updated = prev.map((client) =>
        client.id === orderData.clientId
          ? {
              ...client,
              lastUsed: timestamp,
              orderCount: (client.orderCount || 0) + 1,
            }
          : client,
      )

      immediateQuadrupleSave(
        STORAGE_KEYS.CLIENTS,
        STORAGE_KEYS.CLIENTS_BACKUP,
        STORAGE_KEYS.CLIENTS_EMERGENCY,
        STORAGE_KEYS.CLIENTS_ARCHIVE,
        updated,
      )

      return updated
    })

    console.log("âœ… ORDER PERMANENTLY SAVED WITH ENHANCED TRACKING:", newOrder.id)
    return newOrder
  }

  const updateOrder = (orderId: string, updates: Partial<Order>) => {
    console.log("ðŸ“ Updating order:", orderId)
    const timestamp = new Date().toISOString()

    setOrders((prev) =>
      prev.map((order) =>
        order.id === orderId
          ? {
              ...order,
              ...updates,
              lastModified: timestamp,
            }
          : order,
      ),
    )
  }

  const adjustOrderPricing = (orderId: string, priceAdjustments: Record<string, number>) => {
    console.log("ðŸ”§ Adjusting order pricing:", orderId)
    const timestamp = new Date().toISOString()

    setOrders((prev) =>
      prev.map((order) => {
        if (order.id !== orderId || !order.salesmanPricing) {
          return order
        }

        // Calculate new pricing with adjustments
        const adjustedItemPrices: Record<string, number> = {}
        let adjustedSubtotal = 0

        order.items.forEach((item) => {
          const basePrice = order.salesmanPricing!.itemPrices[item.id] || 0
          const adjustment = priceAdjustments[item.id] || 0
          const finalPrice = basePrice + adjustment
          adjustedItemPrices[item.id] = finalPrice
          adjustedSubtotal += finalPrice * item.requestedQuantity
        })

        const taxRate = order.withGst ? 0.12 : 0
        const adjustedTax = adjustedSubtotal * taxRate
        const adjustedTotal = adjustedSubtotal + adjustedTax

        const updatedPricing = {
          ...order.salesmanPricing,
          subtotal: adjustedSubtotal,
          tax: adjustedTax,
          total: adjustedTotal,
          itemPrices: adjustedItemPrices,
          priceAdjustments,
        }

        return {
          ...order,
          salesmanPricing: updatedPricing,
          items: order.items.map((item) => ({
            ...item,
            unitPrice: adjustedItemPrices[item.id],
            lineTotal: adjustedItemPrices[item.id] * item.requestedQuantity,
          })),
          lastModified: timestamp,
        }
      }),
    )
  }

  const addClient = (clientData: Omit<Client, "id" | "createdAt">) => {
    // Check for duplicates before adding
    const existingClient = checkClientExists(clientData.partyName, clientData.email)
    if (existingClient) {
      throw new Error(
        `Client already exists: ${existingClient.partyName}${existingClient.email ? ` (${existingClient.email})` : ""}`,
      )
    }

    const newClient: Client = {
      ...clientData,
      id: `CLI-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date().toISOString(),
      orderCount: 0,
      lastUsed: new Date().toISOString(),
    }

    console.log("ðŸ¢ Adding new client:", newClient.partyName)
    setClients((prev) => [...prev, newClient])
    return newClient
  }

  const updateClient = (clientId: string, updates: Partial<Client>) => {
    // Check for duplicates when updating name or email
    if (updates.partyName || updates.email) {
      const existingClient = checkClientExists(updates.partyName || "", updates.email)
      if (existingClient && existingClient.id !== clientId) {
        throw new Error(
          `Client already exists: ${existingClient.partyName}${existingClient.email ? ` (${existingClient.email})` : ""}`,
        )
      }
    }

    console.log("ðŸ“ Updating client:", clientId)
    setClients((prev) =>
      prev.map((client) =>
        client.id === clientId
          ? {
              ...client,
              ...updates,
              lastUsed: new Date().toISOString(),
            }
          : client,
      ),
    )

    // Update client name in all related orders if name changed
    if (updates.partyName) {
      setOrders((prev) =>
        prev.map((order) => (order.clientId === clientId ? { ...order, clientName: updates.partyName! } : order)),
      )

      // Update client name in all related bills
      setBills((prev) =>
        prev.map((bill) => (bill.clientId === clientId ? { ...bill, clientName: updates.partyName! } : bill)),
      )
    }
  }

  const deleteClient = (clientId: string) => {
    // Check if client has orders
    const clientOrders = orders.filter((order) => order.clientId === clientId)
    if (clientOrders.length > 0) {
      throw new Error(`Cannot delete client. They have ${clientOrders.length} order(s) associated with them.`)
    }

    console.log("ðŸ—‘ï¸ Deleting client:", clientId)
    setClients((prev) => prev.filter((client) => client.id !== clientId))
  }

  const generateBill = (orderId: string, billType: "regular" | "gst", gstNumber?: string): Bill | null => {
    const order = orders.find((o) => o.id === orderId)
    if (!order) {
      console.error("Order not found for bill generation:", orderId)
      return null
    }

    const currentPricing = order.finalPricing || order.adminPricing || order.salesmanPricing
    if (!currentPricing) {
      console.error("No pricing available for order:", orderId)
      return null
    }

    const newBill: Bill = {
      id: `BILL-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      orderId: order.id,
      orderNumber: order.orderNumber || "",
      salesmanId: order.salesmanId,
      salesmanName: order.salesmanName,
      clientId: order.clientId,
      clientName: order.clientName,
      items: order.items,
      subtotal: currentPricing.subtotal,
      tax: currentPricing.tax,
      total: currentPricing.total,
      billType,
      gstNumber: billType === "gst" ? gstNumber : undefined,
      status: "generated",
      generatedAt: new Date().toISOString(),
      createdBy: "salesman",
    }

    console.log("ðŸ“„ Generating bill:", newBill.id, "for order:", orderId)
    setBills((prev) => [...prev, newBill])

    // Update order to mark bill as generated
    setOrders((prev) =>
      prev.map((o) =>
        o.id === orderId
          ? {
              ...o,
              billGenerated: true,
              billId: newBill.id,
              lastModified: new Date().toISOString(),
            }
          : o,
      ),
    )

    return newBill
  }

  const updateBillStatus = (billId: string, status: Bill["status"], adminNotes?: string) => {
    console.log("ðŸ“ Updating bill status:", billId, "to", status)
    setBills((prev) =>
      prev.map((bill) => {
        if (bill.id === billId) {
          const updatedBill = { ...bill, status, adminNotes }

          if (status === "verified") {
            updatedBill.verifiedAt = new Date().toISOString()
          } else if (status === "processed") {
            updatedBill.processedAt = new Date().toISOString()
          }

          return updatedBill
        }
        return bill
      }),
    )
  }

  const setAdminPricing = (
    orderId: string,
    pricing: Order["adminPricing"],
    adminNotes?: string,
    allowAdjustment?: boolean,
  ) => {
    console.log("ðŸ’° Setting admin pricing for order:", orderId)
    const timestamp = new Date().toISOString()

    setOrders((prev) =>
      prev.map((order) =>
        order.id === orderId
          ? {
              ...order,
              adminPricing: pricing,
              adminNotes,
              allowPriceAdjustment: allowAdjustment || false,
              priceAdjustmentRange: allowAdjustment ? { min: 10, max: 15 } : undefined,
              status: "admin_priced" as const,
              adminPricedAt: timestamp,
              lastModified: timestamp,
              // Update items with admin prices
              items: order.items.map((item) => ({
                ...item,
                adminPrice: pricing?.itemPrices?.[item.id] || 0,
                finalPrice: pricing?.itemPrices?.[item.id] || 0,
              })),
            }
          : order,
      ),
    )
  }

  const setSalesmanAdjustment = (orderId: string, adjustments: Record<string, number>, notes?: string) => {
    console.log("ðŸ”§ Setting salesman adjustment for order:", orderId)
    const timestamp = new Date().toISOString()

    setOrders((prev) =>
      prev.map((order) => {
        if (order.id !== orderId || !order.allowPriceAdjustment || !order.adminPricing) {
          return order
        }

        // Calculate new pricing with adjustments
        const adjustedItemPrices: Record<string, number> = {}
        let adjustedSubtotal = 0

        order.items.forEach((item) => {
          const adminPrice = order.adminPricing!.itemPrices[item.id] || 0
          const adjustment = adjustments[item.id] || 0
          const finalPrice = adminPrice + adjustment
          adjustedItemPrices[item.id] = finalPrice
          adjustedSubtotal += finalPrice * item.requestedQuantity
        })

        const adjustedTax = adjustedSubtotal * 0.1
        const adjustedTotal = adjustedSubtotal + adjustedTax

        const finalPricing = {
          subtotal: adjustedSubtotal,
          tax: adjustedTax,
          total: adjustedTotal,
          itemPrices: adjustedItemPrices,
          adjustments,
        }

        return {
          ...order,
          finalPricing,
          salesmanAdjustmentNotes: notes,
          status: "salesman_adjusted" as const,
          salesmanAdjustedAt: timestamp,
          lastModified: timestamp,
          // Update items with final prices
          items: order.items.map((item) => ({
            ...item,
            finalPrice: adjustedItemPrices[item.id],
          })),
        }
      }),
    )
  }

  const updateOrderStatus = (orderId: string, status: Order["status"]) => {
    console.log("ðŸ“ Updating order status:", orderId, "to", status)
    setOrders((prev) =>
      prev.map((order) =>
        order.id === orderId ? { ...order, status, lastModified: new Date().toISOString() } : order,
      ),
    )
  }

  const approveOrder = (orderId: string) => {
    console.log("âœ… Approving order:", orderId)
    const timestamp = new Date().toISOString()

    setOrders((prev) =>
      prev.map((order) =>
        order.id === orderId
          ? {
              ...order,
              status: "approved" as const,
              approvedAt: timestamp,
              lastModified: timestamp,
            }
          : order,
      ),
    )
  }

  const rejectOrder = (orderId: string, reason: string) => {
    console.log("âŒ Rejecting order:", orderId, "Reason:", reason)
    setOrders((prev) =>
      prev.map((order) =>
        order.id === orderId
          ? {
              ...order,
              status: "rejected" as const,
              adminNotes: reason,
              lastModified: new Date().toISOString(),
            }
          : order,
      ),
    )
  }

  const getOrderPricingSummary = () => {
    const totalOrders = orders.length
    const totalValue = orders.reduce((sum, order) => {
      const pricing = order.finalPricing || order.adminPricing || order.salesmanPricing
      return sum + (pricing?.total || 0)
    }, 0)

    const pendingOrders = orders.filter((order) => order.status === "pending")
    const pendingValue = pendingOrders.reduce((sum, order) => {
      const pricing = order.salesmanPricing
      return sum + (pricing?.total || 0)
    }, 0)

    const approvedOrders = orders.filter((order) => order.status === "approved")
    const approvedValue = approvedOrders.reduce((sum, order) => {
      const pricing = order.finalPricing || order.adminPricing
      return sum + (pricing?.total || 0)
    }, 0)

    const averageOrderValue = totalOrders > 0 ? totalValue / totalOrders : 0

    return {
      totalOrders,
      totalValue,
      pendingValue,
      approvedValue,
      averageOrderValue,
    }
  }

  const refreshData = () => {
    console.log("ðŸ”„ Manually refreshing data with backup recovery...")

    const savedOrders = recoverDataFromAllBackups(
      STORAGE_KEYS.ORDERS,
      STORAGE_KEYS.ORDERS_BACKUP,
      STORAGE_KEYS.ORDERS_EMERGENCY,
      STORAGE_KEYS.ORDERS_ARCHIVE,
      [],
    )

    const savedClients = recoverDataFromAllBackups(
      STORAGE_KEYS.CLIENTS,
      STORAGE_KEYS.CLIENTS_BACKUP,
      STORAGE_KEYS.CLIENTS_EMERGENCY,
      STORAGE_KEYS.CLIENTS_ARCHIVE,
      [],
    )

    const savedBills = recoverDataFromAllBackups(
      STORAGE_KEYS.BILLS,
      STORAGE_KEYS.BILLS_BACKUP,
      STORAGE_KEYS.BILLS_EMERGENCY,
      STORAGE_KEYS.BILLS_ARCHIVE,
      [],
    )

    setOrders(Array.isArray(savedOrders) ? savedOrders : [])
    setClients(Array.isArray(savedClients) ? savedClients : [])
    setBills(Array.isArray(savedBills) ? savedBills : [])

    // Update data integrity
    setDataIntegrity({
      totalOrders: Array.isArray(savedOrders) ? savedOrders.length : 0,
      lastBackup: new Date().toLocaleString(),
      dataVersion: "v7",
      backupCount: 3,
      retentionInfo: {
        totalProtectedOrders: 0,
        ordersNearExpiry: 0,
        archivedOrdersCount: 0,
        retentionPolicyActive: true,
        lastRetentionCheck: new Date().toISOString(),
        nextCleanupDate: new Date(Date.now() + RETENTION_POLICY.CLEANUP_CHECK_INTERVAL).toISOString(),
      },
      permanentProtectionActive: true,
    })
  }

  const clearAllData = () => {
    console.log("ðŸ—‘ï¸ Clearing all data...")
    setOrders([])
    setClients([])
    setBills([])
    setOrderCounter(1)

    // Clear all storage keys
    Object.values(STORAGE_KEYS).forEach((key) => {
      try {
        localStorage.removeItem(key)
      } catch (error) {
        console.error(`Error clearing localStorage key "${key}":`, error)
      }
    })
  }

  // Export backup functionality
  const exportBackup = () => {
    const exportData = {
      orders,
      clients,
      bills,
      orderCounter,
      exportTimestamp: new Date().toISOString(),
      dataVersion: "v7",
    }

    const dataStr = JSON.stringify(exportData, null, 2)
    const dataBlob = new Blob([dataStr], { type: "application/json" })
    const url = URL.createObjectURL(dataBlob)
    const link = document.createElement("a")
    link.href = url
    link.download = `wims-backup-${new Date().toISOString().split("T")[0]}.json`
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)

    console.log("âœ… Backup exported successfully")
  }

  // Create manual backup
  const createManualBackup = () => {
    createMultiLevelBackup(STORAGE_KEYS.ORDERS, STORAGE_KEYS.ORDERS_BACKUP, STORAGE_KEYS.ORDERS_EMERGENCY, orders)
    createMultiLevelBackup(STORAGE_KEYS.CLIENTS, STORAGE_KEYS.CLIENTS_BACKUP, STORAGE_KEYS.CLIENTS_EMERGENCY, clients)
    createMultiLevelBackup(STORAGE_KEYS.BILLS, STORAGE_KEYS.BILLS_BACKUP, STORAGE_KEYS.BILLS_EMERGENCY, bills)

    setDataIntegrity((prev) => ({
      ...prev,
      lastBackup: new Date().toLocaleString(),
    }))

    console.log("âœ… Manual backup created successfully")
  }

  const verifyDataIntegrity = () => {
    const saveCounter = safeLocalStorageGet(STORAGE_KEYS.SAVE_COUNTER, 0)
    const orderCount = orders.length
    const clientCount = clients.length
    const billCount = bills.length

    console.log(`ðŸ” DATA INTEGRITY CHECK #${saveCounter}:`, {
      orders: orderCount,
      clients: clientCount,
      bills: billCount,
      totalRecords: orderCount + clientCount + billCount,
    })

    return {
      saveCounter,
      orderCount,
      clientCount,
      billCount,
      isHealthy: orderCount >= 0 && clientCount >= 0 && billCount >= 0,
    }
  }

  const getOrderRetentionStatus = (orderId: string): RetentionStatus | null => {
    const order = orders.find((o) => o.id === orderId)
    if (!order) return null
    return calculateRetentionStatus(order)
  }

  const getOrdersNearExpiry = (): Order[] => {
    return orders.filter((order) => {
      const status = calculateRetentionStatus(order)
      return status.daysRemaining <= 3 && status.daysRemaining > 0
    })
  }

  const getArchivedOrders = (): Order[] => {
    return safeLocalStorageGet(STORAGE_KEYS.ARCHIVED_ORDERS, [])
  }

  const enforceRetentionPolicyManual = () => {
    console.log("ðŸ”’ Enforcing 30-day retention policy...")
    const protectedOrders = enforceRetentionPolicy(orders)
    setOrders(protectedOrders)

    // Update retention info
    const newRetentionInfo = getRetentionInfo(protectedOrders)
    setRetentionInfo(newRetentionInfo)
    setDataIntegrity((prev) => ({
      ...prev,
      retentionInfo: newRetentionInfo,
    }))

    safeLocalStorageSet(STORAGE_KEYS.LAST_RETENTION_CHECK, new Date().toISOString())
  }

  const getRetentionSummary = () => {
    const currentRetentionInfo = getRetentionInfo(orders)
    const archivedOrders = getArchivedOrders()

    return {
      totalOrders: orders.length,
      protectedOrders: currentRetentionInfo.totalProtectedOrders,
      nearExpiryOrders: currentRetentionInfo.ordersNearExpiry,
      archivedOrders: archivedOrders.length,
      retentionCompliance: true, // Always true as we enforce the policy
    }
  }

  return (
    <OrderContext.Provider
      value={{
        orders,
        clients,
        bills,
        availableItems,
        isDataLoaded,
        orderCounter,
        dataIntegrity,
        addOrder,
        updateOrder,
        adjustOrderPricing,
        addClient,
        updateClient,
        deleteClient,
        checkClientExists,
        getClientById,
        getClientOrderHistory,
        generateBill,
        updateBillStatus,
        setAdminPricing,
        setSalesmanAdjustment,
        updateOrderStatus,
        approveOrder,
        rejectOrder,
        getOrderPricingSummary,
        refreshData,
        clearAllData,
        exportBackup,
        createManualBackup,
        verifyDataIntegrity,
        retentionInfo,
        getOrderRetentionStatus,
        getOrdersNearExpiry,
        getArchivedOrders,
        enforceRetentionPolicy: enforceRetentionPolicyManual,
        getRetentionSummary,
      }}
    >
      {children}
    </OrderContext.Provider>
  )
}

export function useOrders() {
  const context = useContext(OrderContext)
  if (context === undefined) {
    throw new Error("useOrders must be used within an OrderProvider")
  }
  return context
}
